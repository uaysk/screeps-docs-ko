# Creep

크립은 유닛이다. 크립은 움직일 수 있고, 에너지를 수확할 수 있으며, 구조물을 건설할 수 있으며, 다른 크립과 공격하거나 여러가지 작업을 수행할 수 있다. 각각의 크립은 최대 50개의 신체부위로 구성되어 있고, 다음의 유형이 존재한다:
![bodyparts.png](attachment:bodyparts.png)
<table class="table gameplay-info">
    <tbody>
    <tr>
        <th style="width: 20%;">신체부위</th>
        <th style="width: 8%;">건설비용</th>
        <th>1개의 신체부위당 효과</th>
    </tr>
    <tr>
        <td><code style="background: #333; color: #a9b7c6;">MOVE</code></td>
        <td>50</td>
        <td>1초 마다 피로도를 2점 감소시킨다.</td>
</tr>
</table>

</td>
    </tr>
</table>
WORK은(는) 초당 에너지 원으로부터 2개의 에너지 단위를 수확합니다. 광물이나 광맥으로부터 자원 단위 하나를 초당 수확합니다. 구조물을 건설할 때마다 초당 5개의 에너지 단위가 소모됩니다. 100번 타격당했을 때마다 구조물을 복구하며, 복구할 때마다 1 에너지 단위를 소비합니다. 구조물을 해체할 때는 초당 50번의 타격이 가해지고 그 대가로 초당 0.25개의 에너지 단위를 되찾게 됩니다. 컨트롤러를 업그레이드할 때마다 1 에너지 단위가 소비됩니다.</td>
</tr>
</table><script></script>

</p>
</td>
</tr>
<tr>
    <td><code style="background: #333; color: #777;">CARRY</code></td>
    <td>50</td>
    <td>최대 50개의 자원 단위를 함께 운반할 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #f93842;">ATTACK</code></td>
    <td>80</td>
    <td>짧은 사거리 공격으로 한 번에 30회의 피해를 입힐 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #5d80b2;">RANGED_ATTACK</code></td>
    <td>150</td>
    <td>긴 사거리 공격으로 한 번에 10회의 피해를 입힐 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #777;">CARRY</code></td>
    <td>50</td>
    <td>최대 50개의 자원 단위를 함께 운반할 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #f93842;">ATTACK</code></td>
    <td>80</td>
    <td>짧은 사거리 공격으로 한 번에 30회의 피해를 입힐 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #5d80b2;">RANGED_ATTACK</code></td>
    <td>150</td>
    <td>긴 사거리 공격으로 한 번에 10회의 피해를 입힐 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #777;">CARRY</code></td>
    <td>50</td>
    <td>최대 50개의 자원 단위를 함께 운반할 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #f93842;">ATTACK</code></td>
    <td>80</td>
    <td>짧은 사거리 공격으로 한 번에 30회의 피해를 입힐 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #5d80b2;">RANGED_ATTACK</code></td>
    <td>150</td>
    <td>긴 사거리 공격으로 한 번에 10회의 피해를 입힐 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #777;">CARRY</code></td>
    <td>50</td>
    <td>최대 50개의 자원 단위를 함께 운반할 수 있습니다. </td>
</tr>
<tr>
    <td><code style="background: #333; color: #f93842;">ATTACK</code></td>
    <td>80</td>
    <td>짧은 사거리 공격으로 한 번에 30회의 피해를

</p>
<p>3픽셀 이내의 적대적인 모든 크리프/구조물을 1~4회 타격합니다(거리에 따라 다름).</p>

<p>250</p>

<p>자신 또는 다른 크립의 체력을 복원해줍니다. 단거리일 경우에는 1회차마다 12번, 먼 거리에서는 1회차마다 4번입니다.</p>

<p>600</p>

<p>중립적인 방 컨트롤러를 점령합니다. 체격당 1턴 동안 중립적인 방 컨트롤러를 예약하게 됩니다.</p>
</td>
</tr>
</table><!-- Html code generated by Jekyll, a blog processing tool. -->

번역하지 마세요: JavaScript, 대문자로 된 단어도 번역하지 마세요. 이 글을 한국어로 번역하십시오 . : </p>
            <p>적대적인 방 컨트롤러를 공격하면 300 ticks 당 몸의 일부분 타이머가 하향됩니다. </p>
            <p>중립적 인 방 컨트롤러 예약 타이머는 신체 부위 1 개당 1 틱 씩 낮추어집니다. </p>
            <p>이 신체 일부가있는 크립은 600 틱의 짧은 수명을 갖게되며 갱신 할 수 없습니다. </p>
        </td>
    </tr>
    <tr>
        <td><code style="background: #333; color: #fff;">TOUGH</code></td>
        <td>10</td>
        <td>추가 타격 포인트를 갖는 크립의 몸에만 영향을주지만, 피해를받을 확률이 증가합니다. 피해 저항력을 강화하기 위해 부스트됩니다. </td>
    </tr>
    </tbody>
</table>

{% block inherited/RoomObject %}

{% translate %}
{% api_property body array %}
각 요소는 다음과 같은 속성을 포함합니다.
{% api_method_params %}
boost : string | undefined
보스트된 신체 부위의 경우, 이 속성은 보강에 사용되는 광물 유형을 지정합니다. RESOURCE_* 상수 중 하나입니다. 자세한 내용은 <a href="/resources.html">여기</a>를 참조하십시오.
===
type : string
신체 부위 유형 상수 중 하나입니다.
===
hits : number
해당 신체 부위의 남은 총점수입니다.
{% endapi_method_params %}
{% api_property carry object '{"deprecated": true}' %}
Creep.store](#Creep.store)의 별칭입니다.

Don't translate codes like JavaScript, don't translate words that are only in uppercase letters, Translate this article into Korean : {% api_property carryCapacity number '{"deprecated": true}' %}

{% api_property fatigue number %}


{% api_property hits number %}


{% api_property hitsMax number %}

{% api_property id string %}

A unique object identificator.  You can use <a href="#Game. getObjectById"><code>Game. getObjectById</code></a> method to retrieve an object instance by its <code>id</code>. 

{% api_property memory any %}

```javascript
creep.movement fatigue indicator.  If it is greater than zero, the creep cannot move.
The current amount of hit points of the creep.
The maximum amount of hit points of the creep.
A unique object identificator. You can use <a href="#Game. getObjectById"><code>Game. getObjectById</code></a> method to retrieve an object instance by its <code>id</code>. 
Additional memory for the object.

메모리. task = 'building';

기억해야 할 단축키가 하나 더 있다. Memory.creeps[creep.name]은 신속하게 크립의 특정 메모리 데이터를 얻는 데 사용될 수 있다. 자세한 내용은 <a href="/global-objects.html#Memory-object">여기</a>에서 알아보자.

{% api_property my boolean %}

이것이 당신의 크립인지, 적인지는 중요하지 않다.
{% api_property name string %}

크립의 이름. 새로운 크립을 만들 때 이름을 선택할 수 있고, 나중에는 변경할 수 없다. 해시 키를 통해 Game.creeps 객체를 통한 크립의 접근이 가능하다.

크립의 소유자 정보를 포함하는 객체로, 다음 속성을 가집니다.

{% api_method_params %}
username : string
소유자 사용자의 이름입니다. {% endapi_method_params %}


{% api_property saying string %}


마지막 틱에서 크립이 말하고 있던 문자 메시지입니다. {% api_property_end %}


{% api_property spawning boolean %}


더 이상 스포잉되지 않는지 여부입니다. {% api_property_end %}


{% api_property store '<a href="#Store">Store</a>' %}
```javascript
if(creep.store[RESOURCE_ENERGY] < creep.store.getCapacity()) {
    goHarvest(creep);
}
```
크립의 적재물을 포함하는 '[Store](#Store)' 객체입니다.

{% api_property ticksToLive number %}

남은 게임 틱 수 이후에 크립이 죽습니다.

{% api_method attack 'target' A %}
```javascript
const target = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
if (target) {
    if (creep.attack(target) == ERR_NOT_IN_RANGE) {
        creep.moveTo(target);
    }
}
```
다른 크립, 파워 크립 또는 건물을 근거리 공격합니다. <code>ATTACK</code> 바디 부분이 필요합니다. 타겟이 램파드 안에 있으면 대신 램파드를 공격합니다. 타겟은 크립과 인접한 사각형에 있어야 합니다.

목표가 <code>ATTACK</code> body parts를 갖고 있는 크립이거나, rampart 내에 있지 않다면, 그것은 자동으로 공격자에게 반격을 가할 것입니다.

{% api_method_params %}
target : <a href="#Creep">크립</a>, <a href="#PowerCreep">파워 크립</a>, <a href="#Structure">구조물</a>
공격할 대상 객체.
{% endapi_method_params %}

### 반환값
다음 코드 중 하나:
{% api_return_codes %}
OK | 작업을 성공적으로 예약했습니다.
ERR_NOT_OWNER | 이 크립의 소유자가 아닙니다.
ERR_BUSY | 크립이 여전히 생성 중입니다.
ERR_INVALID_TARGET | 타겟은 공격할 수 있는 유효한 객체가 아닙니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 떨어져 있습니다.

ERR_NO_BODYPART | 이 곤충의 몸에는 <code>ATTACK</code> 본체가 없습니다.
{% endapi_return_codes %}

목표는 해당 크리프의 인접한 사각형에 있어야 합니다.
{% api_method_params %}
target : <a href="#StructureController">구조 컨트롤러</a>
목표 컨트롤러 객체.
{% endapi_method_params %}

### 반환 값
다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 해당 크리프의 소유자가 아닙니다.
ERR_BUSY | 해당 크리프가 여전히 생성 중입니다.
ERR_INVALID_TARGET | 목표는 유효한 소유된 또는 예약된 컨트롤러 객체가 아닙니다.
ERR_NOT_IN_RANGE | 목표가 너무 멀리 있습니다.
ERR_NO_BODYPART | 해당 크리프의 신체에 <code>CLAIM</code> 바디 파트가 충분하지 않습니다.

ERR_TIRED | 다음에 공격할 수 있을 때까지 기다려야 합니다.
{% endapi_return_codes %}

{% api_method build 'target' A %}

```javascript
const target = creep. pos. findClosestByRange(FIND_CONSTRUCTION_SITES);
if(target) {
    if(creep. build(target) == ERR_NOT_IN_RANGE) {
        creep. moveTo(target);
    }
}

```

<code>WORK</code>와 <code>CARRY</code> 신체 부위를 사용하여 타겟 건설 현장에 구조물을 지으십시오. 타겟이 크립의 3칸 범위 내에 있어야 합니다.
{% api_method_params %}
target : <a href="#ConstructionSite">ConstructionSite</a>
건설할 대상 현장

### Return value

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 당신은 해당 <code>creep</code>의 소유자가 아닙니다.
ERR_BUSY | 해당 <code>creep</code>가 여전히 스폰 중입니다.
ERR_NOT_ENOUGH_RESOURCES | 해당 <code>creep</code>는 에너지를 운반하지 않습니다.
ERR_INVALID_TARGET | 대상은 유효한 건설 현장 객체가 아닙니다. 또는 이 위치에서 <code>structure</code>을 건축할 수 없습니다(아마도 같은 광장의 <code>creep</code> 때문일 것입니다).
ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다.
ERR_NO_BODYPART | 해당 <code>creep</code>의 신체에는 <code>WORK</code> 부위가 없습니다

target)) {
        console.log("Successfully claimed the controller for " + creep.name);
    } else {
        console.log("Failed to claim the controller for " + creep.name);
    }
}
```

Claim a room's controller for a given creature. 
{% api_method_params %}
target : string
The name of the creature that will claim the controller. 
A : string
The name of the target room to claim as its controller. 
{% endapi_method_params %}

### Return value

One of the following codes:
{% api_return_codes %}
OK | The controller was successfully claimed for the given creature. 
ERR_TARGET_NOT_FOUND | The target creature with the specified name was not found. 
ERR_CONTROLLER_ALREADY_OCCUPIED | The target room is already under the control of another creature. 
ERR_CONTROLLER_UNFOUND | The target room does not have a controller. 
{% endapi_return_codes %}


{% api_method createCreep 'type' stats 'health' strength 'armor' speed A B C D E F G H I J K L M N O P Q R S T U V W X Y Z %}
```javascript
var creep = new Creep(type, stats, health, strength, armor, speed);
creep.setName(name);
//Add any other properties or methods you need to the creature object

creep.create(); //The create method will be called automatically when this object is used in game logic
```

목표 컨트롤러 객체입니다.

{% api_method_return_values %}

success : <code>Promise.resolve(undefined)</code>

errors :
    <code>ERR_NO_ROOM</code>: 목표 룸이 없습니다.
    <code>ERR_NOT_YOUR_CONTROLLER</code>: 목표 컨트롤러가 아닙니다.
    <code>ERR_INCORRECT_PARAMS</code>: 잘못된 매개변수입니다.
    <code>ERR_NOT_ENOUGH_GCL</code>: 글로벌 컨트롤 레벨이 부족합니다.
    <code>ERR_ALREADY_CRAFTED</code>: 목표 객체는 이미 제작되었습니다.
    <code>ERR_OWNERSHIP_DISPUTE</code>: 소유권 분쟁이 있습니다.
    <code>ERR_CONSTRUCTION_IN_PROGRESS</code>: 건설이 진행중입니다.
    <code>ERR_CONTRACT_IN_PROGRESS</code>: 계약 체결 중입니다.
    <code>ERR_NOT_FOUND</code>: 목표를 찾을 수 없습니다.
    <code>ERR_TARGET_ALREADY_CLAIMED</code>: 목표는 이미 주장되었습니다.
    <code>ERR_INVALID_ARGUMENT</code>: 올바르지 않은 인수입니다.
    <code>ERR_NOT_IN_RANGE</code>: 목표 컨트롤러가 밖으로 나갔습니다.
    <code>ERR_NO_TARGET</code>: 목표가 없습니다.
    <code>ERR_INVALID_STRING</code>: 잘못된 문자열입니다.
    <code>ERR_NOT_IN_ROOM</code>: 대상 객체가 방에 있지 않습니다.
    <code>ERR_ALREADY_OWNER</code>: 이미 소유권이 주장되었습니다.
    <code>ERR_INCORRECT_TYPE</code>: 잘못된 유형입니다.
    <code>ERR_NOT_ENOUGH_CREW</code>: 승무원 레벨이 부족합니다.
    <code>ERR_CRAFTING_TIMEOUT</code>: 제작 시간 초과

10000000000000000000000000000000

찾기 힘든 구조물을 찾습니다.
```
findClosestByRange(FIND_STRUCTURES,
{filter: {structureType: STRUCTURE_WALL}});
```

if(target) {
    if(creep.dismantle(target) == ERR_NOT_IN_RANGE) {
        creep.moveTo(target);
    }
}
```

drop(resourceType, creep.carry[resourceType]);
}
```

### Return value

One of the following codes:
{% api_return_codes %}
OK | The resources have been dropped successfully. 
ERR_NOT_OWNER | You are not the owner of this creep. 
ERR_BUSY | The creature is still being spawned. 
ERR_INVALID_TARGET | The target is not a valid structure object. 
ERR_NOT_IN_RANGE | The target is too far away. 
ERR_NO_BODYPART | There are no <code>WORK</code> body parts in this creature’s body. 
{% endapi_return_codes %}

### Parameters

```javascript
creep. drop(resourceType, [amount]);
```

- `resourceType`: The type of resource to be dropped (e.g. ENERGY). 
- `[amount]`: The amount of the resource to be dropped (optional). If not provided, the entire amount of the specified resource will be dropped.

{% api_method_params %}

{% endapi_method_params %}

```javascript
function generateSafeMode(roomController) {
    if (roomController. safeModeActivationsAvailable == 0 &&
        // check if creep has enough resources
        creep.resources >= 1000 &&
        // check if creep is at adjacent square to room controller
        (Math.abs(creep.pos.x - roomController.pos.x) <= 1 || Math.abs(creep.pos.y - roomController.pos.y) <= 1)) {
        roomController.safeModeActivationsAvailable--;
        roomController.activateSafeMode();
    }
}
```

18617294534.type === "BodyPart" && object.ownerId !== creep.id;
    },
    limit: 1
});
creep.setTarget(target);
```

활성 신체 부위의 수를 반환합니다. 완전히 손상된 부분은 포함되지 않습니다.

{% api_method_params %}
type : string
신체 부위 유형입니다. 다음 중 하나의 값을 가질 수 있는 문자열입니다.
<ul>
    <li><code>MOVE</code></li>
    <li><code>WORK</code></li>
    <li><code>CARRY</code></li>
    <li><code>ATTACK</code></li>
    <li><code>RANGED_ATTACK</code></li>
    <li><code>HEAL</code></li>
    <li><code>TOUGH</code></li>
</ul>
{% endapi_method_params %}

### 반환 값

신체 부위의 수를 나타내는 숫자입니다.

{% api_method_params end %}

{% api_method harvest 'target' A %}

### API 메서드 매개변수 번역하기{% endapi_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 당신은 그림자 인간의 소유자가 아닙니다. 또는 방 컨트롤러가 다른 플레이어의 소유 또는 예약되었습니다.
ERR_BUSY | 그림자 인간이 여전히 생성중입니다.
ERR_NOT_FOUND | 추출기를 찾을 수 없습니다. 미네랄을 수확하려면 추출기 구조물을 건설해야 합니다. <a href="/resources.html">자세히 알아보기</a>
ERR_NOT_ENOUGH_RESOURCES | 대상에는 수확할 수 있는 에너지나 미네랄이 없습니다.
ERR_INVALID_TARGET | 대상은 유효한 소스 또는 광물 개체가 아닙니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다.

ERR_TIRED | 추출기나 보관소가 아직 식고 있습니다.
ERR_NO_BODYPART | 해당 크리프의 신체에 <code>WORK</code> 부분이 없습니다.
{% endapi_return_codes %}

대상은 크리프의 옆에 있어야 합니다.
{% api_method_params %}
target : <a href="#Creep">크리프</a>, <a href="#PowerCreep">파워 크리프</a>
대상 크리프 객체.
{% endapi_method_params %}

### 반환값
다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 이 크리프의 소유자가 아닙니다.
ERR_BUSY | 크리프가 생성 중입니다.
ERR_INVALID_TARGET | 대상은 올바르지 않습니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다.
ERR_NO_BODYPART | 크리프의 신체에 <code>HEAL</code> 신체 부위가 없습니다.

{% endapi_return_codes %}

{% api_method move 'direction' A %}

```javascript
creep.move(RIGHT);
```

```javascript
const path = creep.pos.findPathTo(Game.flags.Flag1);
if (path.length > 0) {
  creep.move(path[0].direction);
}
```

```javascript
creep1.move(TOP);
creep1.pull(creep2);
creep2.move(creep1);
```

'MOVE'를 사용하여 크립을 한 칸 이동시킵니다. '<code>MOVE</code>' 바디 부분이나 가까운 곳의 또 다른 크립이 <a href="#Creep. pull">당기고 있는</a> 경우 가능합니다.

<code>move</code> 를 근처의 크립에서 호출하는 경우 <code>ERR_TIRED</code> 및 <code>ERR_NO_BODYPART</code> 확인이 무시됩니다. 그렇지 않으면 <code>ERR_NOT_IN_RANGE</code> 확인이 무시됩니다.</code>

<div>
<code>{% api_method_params %}
direction : <a href="#Creep">Creep</a>|number
A nearby creep, or one of the following constants:
						<ul>
							<li><code>TOP</code></li>
							<li><code>TOP_RIGHT</code></li>
							<li><code>RIGHT</code></li>
							<li><code>BOTTOM_RIGHT</code></li>
							<li><code>BOTTOM</code></li>
							<li><code>BOTTOM_LEFT</code></li>
							<li><code>LEFT</code></li>
							<li><code>TOP_LEFT</code></li>
					</ul>
{% endapi_method_params %}


### Return value

One of the following codes:
{% api_return_codes %}
OK | The operation has been scheduled successfully. 
ERR_NOT_OWNER | You are not the owner of this creep. 
ERR_BUSY | The creep is still being spawned.</code>
</div>

---

<div>
{% api_method_params %}
direction : <a href="#Creep">Creep</a>|number
A nearby creep, or one of the following constants:
						<ul>
							<li><code>TOP</code></li>
							<li><code>TOP_RIGHT</code></li>
							<li><code>RIGHT</code></li>
							<li><code>BOTTOM_RIGHT</code></li>
							<li><code>BOTTOM</code></li>
							<li><code>BOTTOM_LEFT</code></li>
							<li><code>LEFT</code></li>
							<li><code>TOP_LEFT</code></li>
					</ul>
{% endapi_method_params %}


### Return value

One of the following codes:
{% api_return_codes %}
OK | The operation has been scheduled successfully. 
ERR_NOT_OWNER | You are not the owner of this creep. 
ERR_BUSY | The creep is still being spawned.</div>

ERR_TIRED | 크립의 피로도가 0이 아닙니다.
ERR_NO_BODYPART | 이 크립의 신체에 MOVE 부위가 없습니다.
ERR_INVALID_ARGS | 제공된 방향이 정확하지 않습니다.
ERR_NOT_IN_RANGE | 대상 크립과의 거리가 너무 멉니다.
{% endapi_return_codes %}

{% api_method moveByPath '경로' A %}

```javascript
const path = spawn.room.findPath(spawn, source);
creep.moveByPath(path);
```

```javascript
if(! creep.memory.path) {
    creep.memory.path = creep.pos.findPathTo(target);
}
creep.moveByPath(creep.memory.path);
```

지정된 미리 정의된 경로를 사용하여 크립을 이동시킵니다. <code>MOVE</code> 바디 파트가 필요합니다.

코드를 번역하지 마십시오. JavaScript, 대문자로만 쓰인 단어도 번역하지 마십시오. 이 글을 한국어로 번역하십시오. : {% api_method_params %}
path : array|string
<a href="#Room. findPath"><code>Room. findPath</code></a>, <a href="#RoomPosition. findPathTo"><code>RoomPosition. findPathTo</code></a>, 또는 <a href="#PathFinder. search"><code>PathFinder. search</code></a> 메소드에서 반환된 경로 값입니다. 배열 형태와 문자열 형태 모두 허용됩니다.
{% endapi_method_params %}

### 반환 값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 사용자가 크립의 소유주가 아닙니다.
ERR_BUSY | 크립이 생성 중입니다.
ERR_NOT_FOUND | 지정된 경로가 크립의 위치와 일치하지 않습니다.

ERR_INVALID_ARGS | <code>path</code>가 올바른 경로 배열이 아닙니다. ERR_TIRED | 크립의 피로 지표가 0이 아닙니다. ERR_NO_BODYPART | 이 크립의 신체에는 <code>MOVE</code> 부위가 없습니다. {% endapi_return_codes %}

{% api_method moveTo 'x, y, [opts]|target, [opts]' 3 %}

```javascript
creep. moveTo(10, 20);
```

```javascript
creep. moveTo(Game. flags. Flag1);
```

```javascript
creep. moveTo(new RoomPosition(25, 20, 'W10N5'));
```

```javascript
creep. moveTo(pos, {reusePath: 50});
```

```javascript
// 처음에는 캐시된 경로를 통해 이동을 실행합니다. for(const name in Game. creeps) {
    Game. creeps[name].moveTo(pos, {reusePath: 50});
}
```

{% api_response_params %}
moveTo(target, {noPathFinding: true});

// Pathfinding을(를) 수행할지 여부는 CPU의 사용률에 따라 결정됩니다.if(Game.cpu.tickLimit - Game.cpu.getUsed() > 20) {
    for(const name in Game.creeps) {
        Game.creeps[name].moveTo(target);
    }
}
```

===
y : number
Y 위치를 같은 방에 있는 목표에 대한 값입니다. 
===
target : object
<a href="#RoomPosition">RoomPosition</a> 객체나 <a href="#RoomPosition">RoomPosition</a>을 포함하고 있는 객체일 수 있습니다. 대상의 위치가 반드시 크립과 같은 방에 있지 않아도 됩니다.
===
opts (선택적) : object
추가 옵션이 포함된 객체입니다:
						<ul>
							<li>
								 <div class="api-arg-title">reusePath</div>
								 <div class="api-arg-type">number</div>
								 <div class="api-arg-desc">여러 게임 틱에서 찾은 경로를 재사용하도록 설정합니다. CPU 시간을 절약할 수 있지만, 크립의 반응 속도가 조금 느려질 수 있습니다.</div>
							</li>
						</ul>

경로는 <code>_move</code> 속성에 크립의 메모리에 저장됩니다. <code>reusePath</code> 값은 경로가 재사용되어야하는 틱의 수를 정의합니다. 기본값은 5입니다. CPU를 절약하려면 양을 늘리고, 움직임을 일관되게 만들기 위해 줄이십시오. <code>reusePath</code>가 0인 경우 경로 재사용을 비활성화하려면.</div>
						</li>
						<li>
							<div class="api-arg-title">serializeMemory</div>
							<div class="api-arg-type">boolean</div>
							<div class="api-arg-desc"><a href="#Room. serializePath"><code>Room.</code>를 사용하여 단순화된 형태로 메모리에 경로가 저장되는지 여부입니다. <code>reusePath</code>가 활성화된 경우 이 옵션을 true로 설정합니다.</div>
						</li>
</ul>

번역하지 마세요. JavaScript 코드를 번역하지 마세요. 대문자로만 된 단어도 번역하지 마세요. 이 문서를 한국어로 번역하십시오. : serializePath</code></a>. 기본값은 true입니다. </div>
						</li>
						<li>
							<div class="api-arg-title">noPathFinding</div>
							<div class="api-arg-type">boolean</div>
							<div class="api-arg-desc">이 옵션을 true로 설정하면 <code>moveTo</code> 메서드가 사용할 수 없는 경로를 기억하지 않으므로 ERR_NOT_FOUND를 반환합니다. 일부 경우에서는 CPU 시간을 상당히 절약할 수 있습니다. 기본값은 false입니다. </div>
					</li>
						<li>
							<div class="api-arg-title">visualizePathStyle</div>
							<div class="api-arg-type">object</div>
							<div class="api-arg-desc"><a href="#RoomVisual.poly"><code>RoomVisual.</code></a> 을 사용하여 경로를 따라 선을 그립니다. </div>
</li>
</ul>
</body>
</html>
</div>
<div class="language__content">
	<h1>Creep.moveTo()</h1>
	<p>The <code>moveTo()</code> method of the Creep object is used to move a creeping entity (like a <a href="https://en.wikipedia.org/wiki/Ant">ant</a>) from one point to another on a path. The method returns <code>ERR_NOT_FOUND</code> if there is no memorized path to reuse.</p>
	<h2>Properties</h2>
	<ul>
		<li>
			<div class="api-arg-title">path</div>
			<div class="api-arg-type">object</div>
			<div class="api-arg-desc">The memorized path to reuse. It is created using <code>createPath()</code> method. </div>
		</li>
		<li>
			<div class="api-arg-title">serializePath</div>
			<div class="api-arg-type">boolean</div>
			<div class="api-arg-desc">If this option is set to true, <code>moveTo()</code> method will serialize the path using <code>serializePath()</code> and deserialize it at the destination.  This can help in reducing network traffic if the path information is not available at the remote end.  The default value is false. </div>
		</li>
		<li>
			<div class="api-arg-title">usePath</div>
			<div class="api-arg-type">boolean</div>
			<div class="api-arg-desc">If this option is set to true, the <code>moveTo()</code> method will use the memorized path for movement.  The default value is false. </div>
		</li>
		<li>
			<div class="api-arg-title">noPathFinding</div>
			<div class="api-arg-type">boolean</div>
			<div class="api-arg-desc">If this option is set to true, <code>moveTo()</code> method will return <code>ERR_NOT_FOUND</code> if there is no memorized path to reuse.  This can significantly save CPU time in some cases.  The default value is false. </div>
		</li>
		<li>
			<div class="api-arg-title">visualizePathStyle</div>
			<div class="api-arg-type">object</div>
			<div class="api-arg-desc">Draw a line along the creep’s path using <a href="#RoomVisual. poly"><code>RoomVisual.</code></a> 을 사용하여 경로를 따라 선을 그립니다. </div>
	</li>
</ul>
<h2>Methods</h2>
<p>The <code>moveTo()</code> method can also take an optional second argument that is a function. This function can be used to define a callback which is called after the creeping is done. The callback can accept two arguments: the progress of the creeping as a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Global_Objects/Event/progress">event</a>, and a boolean showing whether the creeping was successful or not.</p>
<pre><code class="language-javascript">
Creep.moveTo(path, function(progress, success) {
    if (!success) {
        // handle failure here
    } else {
        // handle success here
    }
})
</code></pre>
</div>
<div class="language__notes">
	<p><a href="#RoomVisual. poly"><code>RoomVisual.</code></a> 을 사용하여 경로를 따라 선을 그립니다.</p>
</div>
</div>
</body>
</html>

poly</code></a> 스타일은 JavaScript에서 사용할 수 없습니다. 빈 객체나 자체 스타일 매개변수를 제공해도 됩니다. 기본 스타일은 다음과 같이 표현될 수 있습니다:
<pre class="language-javascript"><code>{
    fill: 'transparent',
    stroke: '#fff',
    lineStyle: 'dashed',
    strokeWidth: .15,
    opacity: .1
}</code></pre>
</div>
<li>Room. findPath 메서드가 지원하는 모든 옵션.</li>
{% endapi_method_params %}

### 반환값
성공적으로 작업을 예약한 경우:
ERR_NOT_OWNER | 사용자가 해당 크립트의 소유자가 아닙니다.
ERR_BUSY | 크립트가 아직 생성되고 있습니다.

ERR_TIRED | 유동체의 피로 표시가 0이 아닙니다.
ERR_NO_BODYPART | 이 MOVE 신체 부위에는 신체 부위가 없습니다.
ERR_INVALID_TARGET | 제공된 대상이 잘못되었습니다.
ERR_NO_PATH | 대상으로 갈 경로를 찾을 수 없습니다.
ERR_NOT_FOUND | 이 유동체는 기억하고 있는 경로가 없습니다.
{% endapi_return_codes %}


{% api_method notifyWhenAttacked 'enabled' A %}

```javascript
if(creep.memory.role == 'scout') {
	creep.notifyWhenAttacked(false);
}
else {
	creep.notifyWhenAttacked(true);
}
```

자동 알림을 토글합니다. 유동체가 공격받았을 때 이 알림은 계정 이메일로 전송됩니다. 기본적으로 'enabled'로 설정됩니다.

활성화 : 불린
알림을 사용할지 아닌지를 결정합니다.
{% endapi_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 성공적으로 작업이 예약되었습니다. 
ERR_NOT_OWNER | 당신은 이 크립트의 소유자가 아닙니다. 
ERR_BUSY | 크립트가 여전히 소환중입니다. 
ERR_INVALID_ARGS | <code>enable</code> 인수는 불린 값이 아닙니다. 
{% endapi_return_codes %}


{% api_method pickup 'target' A %}

```javascript
const target = creep. pos. findClosestByRange(FIND_DROPPED_RESOURCES);
if(target) {
    if(creep. pickup(target) == ERR_NOT_IN_RANGE) {
        creep.

<code>moveTo(target);</code>
```

대상을 집어 올립니다 (에너지 부스러기를 픽업합니다). <code>CARRY</code> 신체 부위가 필요합니다. 대상이 크립의 인접한 칸이나 동일한 칸에 있어야 합니다.
{% api_method_params %}
target : <a href="#Resource">리소스</a>
픽업할 대상 객체입니다.
{% endapi_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 이 크립의 소유자가 아닙니다.
ERR_BUSY | 크립을 생성하는 중입니다.
ERR_INVALID_TARGET | 픽업할 대상이 올바르지 않습니다.
ERR_FULL | 크립에 더 이상 리소스를 받을 수 없습니다.

ERR_NOT_IN_RANGE | 목표물이 너무 멀리 있습니다.
{% endapi_return_codes %}

{% api_method pull 'target' 0 %}

```javascript
creep1. move(TOP);
creep1. pull(creep2);
creep2. move(creep1);
```

```javascript
const target = creep.pos.findClosestByRange(FIND_MY_CREEPS, {
    filter: function(object) {
        return (object.getActiveBodyparts(MOVE) == 0) &&
            object.memory.destinationId &&
            ! object.pos.isNearTo(Game.getCObjectById(object.memory.destinationId));
    }
});
if(target) {
    if(creep.pull(target) == ERR_NOT_IN_RANGE) {
        creep.moveTo(target);
    } else {
        target.move(creep);
        if(creep.pos.isNearTo(Game.getCObjectById(target.memory.destinationId))) {
            target.memory.destinationId = null;
        }
    }
}
```

목표 크립입니다.

### 반환값

다음 중 하나의 코드:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 당신은 이 creep의 소유자가 아닙니다.
ERR_BUSY | 이 creep은 여전히 생성중입니다.
ERR_INVALID_TARGET | 제공된 대상이 올바르지 않습니다.
ERR_NOT_IN_RANGE | 목표가 너무 멀리 있습니다.
{% endapi_return_codes %}


{% api_method rangedAttack 'target' A %}

```javascript
const targets = creep. pos. findInRange(FIND_HOSTILE_CREEPS, 3);
if(targets. length > 0) {
    creep. rangedAttack(targets[0]);
}

```

다른 creep나 구조물을 원거리에서 공격하는 행위입니다. <code>RANGED_ATTACK</code> body part가 필요합니다.

목표가 요새 안에 있으면, 그 요새를 대신 공격합니다. 목표는 크립에서 3칸 범위 이내여야 합니다.
{% api_method_params %}
target : <a href="#Creep">Creep</a>, <a href="#PowerCreep">파워크립</a>, <a href="#Structure">구조물</a>
공격할 대상 객체입니다.
{% endapi_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업을 성공적으로 예약했습니다.
ERR_NOT_OWNER | 사용자가 해당 크립의 소유주가 아닙니다.
ERR_BUSY | 크립이 여전히 스폰되고 있습니다.
ERR_INVALID_TARGET | 대상이 공격 가능한 객체가 아닙니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 떨어져 있습니다.

ERR_NO_BODYPART | 이 크립의 몸에는 <code>RANGED_ATTACK</code> 신체 부위가 없습니다.
{% endapi_return_codes %}

{% api_method rangedHeal 'target' A %}

```javascript
const target = creep.pos.findClosestByRange(FIND_MY_CREEPS, {
    filter: function(object) {
        return object.hits < object.hitsMax;
    }
});
if(target) {
    creep.moveTo(target);
    if(creep.pos.isNearTo(target)) {
        creep.heal(target);
    }
    else {
        creep.rangedHeal(target);
    }
}
```

다른 크립의 몸에서 치료하십시오. 그것은 목표 크립의 손상된 신체 부위 기능을 복원하고 피격 카운터를 증가시킵니다. <code>HEAL</code> 신체 부위가 필요합니다.

대상이 크립의 사각형 범위 3 내에 있어야 합니다.

{% api_method_params %}
target : <a href="#Creep">크립</a>, <a href="#PowerCreep">파워크립</a>
대상 크립 객체. 
{% endapi_method_params %}

### 반환값
다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다. ERR_NOT_OWNER | 현재 사용자가 해당 크립의 소유자가 아닙니다. ERR_BUSY | 현재 해당 크립이 부화 중입니다. ERR_INVALID_TARGET | 대상이 올바르지 않은 크립 객체입니다. ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다. ERR_NO_BODYPART | 해당 크립의 신체에 <code>HEAL</code> 부위가 없습니다

JavaScript 코드를 번역하지 마십시오. code 또는 대문자로만 이루어진 단어를 번역하지 마십시오. {% endapi_return_codes %}

```javascript
const targets = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 3);
if (targets.length > 0) {
    creep.rangedMassAttack();
}
```

```javascript
A ranged attack against all hostile creeps or structures within 3 squares range.
Requires the RANGED_ATTACK body part. The attack power depends on the range to each target. Friendly units are not affected.

### Return value
One of the following codes:
{% api_return_codes %}
OK | The operation has been scheduled successfully.
ERR_NOT_OWNER | You are not the owner of this creep.
ERR_BUSY | The creep is still being spawned.```

ERR_NO_BODYPART | <code>RANGED_ATTACK</code> 신체 부위가 없습니다. 이 크리프의 몸에.
{% endapi_return_codes %}

수리할 대상 구조물입니다.
{% api_method_params %}
target : <a href="#Structure">구조</a>
{% endapi_method_params %}

### 반환값
다음과 같은 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 귀하는 해당 <code>creep</code>의 소유자가 아닙니다.
ERR_BUSY | 해당 <code>creep</code>은 여전히 생성 중입니다.
ERR_NOT_ENOUGH_RESOURCES | 해당 <code>creep</code>에는 에너지가 없습니다.
ERR_INVALID_TARGET | 대상이 올바르지 않은 구조물입니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다.
ERR_NO_BODYPART | 해당 <code>creep</code>의 신체에는 <code>WORK</code> 보디파트가 없습니다.

{% endapi_return_codes %}
{% api_method reserveController 'target' A %}

```javascript
if(creep. room. controller) {
    if(creep. reserveController(creep. room. controller) == ERR_NOT_IN_RANGE) {
        creep. moveTo(creep. room. controller);
    }
}

```

일시적으로 중립 컨트롤러가 다른 플레이어에 의해 클레임되는 것을 차단하고 에너지 소스를 최대 용량으로 복원합니다. 매 틱마다 이 명령은 <code>CLAIM</code> 바디 부분이 한 번씩 늘어나는 동안 컨트롤러를 사용할 수 없는 기간의 카운터를 증가시킵니다. 최대 유지할 예약 기간은 5,000 틱입니다. 타겟은 크립과 인접한 사각형이어야 합니다.

목표 컨트롤러 객체를 예약하려면 다음을 사용하십시오. {% api_method_params %}
target : <a href="#StructureController">구조 컨트롤러</a>
{% endapi_method_params %}

### 반환값
다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 당신은 그러한 크립트의 소유자가 아닙니다.
ERR_BUSY | 크립은 여전히 생성중입니다.
ERR_INVALID_TARGET | 목표는 유효한 중립적인 컨트롤러 객체가 아닙니다.
ERR_NOT_IN_RANGE | 목표가 너무 멀리 있습니다.
ERR_NO_BODYPART | 이 크립의 몸에는 <code>CLAIM</code> 신체 부위가 없습니다.

0이(가) {% endapi_return_codes %}
를(를) 번역했습니다

.controller.room);
    } else {
        alert(creep. text);
    }
}
```

```javascript
Creeps are not yet able to sign their controllers, so the method is disabled.  However, you can still pass in an object for the text parameter.

controller) {{{#if isValid}}>
    <valid-message/>
{{{#if isScheduled}}>
    <scheduled-message/>
{{{#if isSuccess}}>
    <success-message/>
{{{#if hasResults}}>
    <results message/>
{{/if}}}{{{#if isError}}>
    <error-message/>
{{/if}}}
{{/if}}}

```

컨트롤러에 임의의 텍스트를 서명하여 모든 플레이어가 볼 수 있도록 합니다. 이 텍스트는 방 인터페이스, 월드 지도에 표시되며 API를 통해 액세스할 수 있습니다. 소유권이 없고 적대적인 컨트롤러를 서명할 수 있습니다. 대상은 크립과 인접한 사각형에 있어야 합니다. 빈 문자열을 전송하여 서명을 제거할 수 있습니다.

{% api_method_params %}
target : <a href="#StructureController">StructureController</a>
서명할 대상 컨트롤러 객체를 지정합니다.
===
text : string
서명 텍스트입니다. 문자열은 100자로 잘립니다.
{% endapi_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.

ERR_BUSY | 대상이 아직 생성되고 있습니다. 
ERR_INVALID_TARGET | 대상은 유효하지 않은 컨트롤러 객체입니다. 
ERR_NOT_IN_RANGE | 목표가 너무 멀리 있습니다. 
```



{% endapi_return_codes %}



{% api_method suicide '' A %}




즉시 크립을 삭제합니다.



### 반환 값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다. 
ERR_NOT_OWNER | 사용자가 크립의 소유자가 아닙니다. 
ERR_BUSY | 크립이 여전히 생성되고 있습니다. 
{% endapi_return_codes %}



{% api_method transfer 'target, resourceType, [amount]' A %}
```javascript
if(creep.transfer(storage, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
	creep.ownerId = 1;
}
```

이동시킵니다(저장).
}
```

```javascript
// 모든 자원을 이전합니다.
for(const resourceType in creep. carry) {
	creep. transfer(storage, resourceType);
}
```

<code>creep</code>에서 자원을 <a href="#Target">타겟</a> 개체로 이전합니다. <br><br>타겟은 <code>creep</code>와 인접한 사각형에 있어야 합니다.<br><br>{% api_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.
ERR_NOT_OWNER | 당신은 그 크리프의 소유자가 아닙니다.
ERR_BUSY | 크립이 스폰되고 있습니다.
ERR_NOT_ENOUGH_RESOURCES | 그 크립에는 주어진 양의 리소스가 없습니다.
ERR_INVALID_TARGET | 타겟은 지정된 자원을 포함할 수 있는 유효한 객체가 아닙니다.
ERR_FULL | 타겟에는 더 이상 리소스를 받을 수 없습니다.
ERR_NOT_IN_RANGE | 타겟이 너무 멀었습니다.
ERR_INVALID_ARGS | resourceType은 RESOURCE_* 상수 중 하나가 아니거나 양이 부정확합니다.

{% endapi_return_codes %}

{% api_method upgradeController 'target' A %}

```javascript
if(creep.room.controller) {
    if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
        creep.moveTo(creep.room.controller);
    }
}

```

컨트롤러를 업그레이드하여 수송 가능한 에너지를 사용합니다. 컨트롤러 업그레이드는 글로벌 제어 수준을 동시에 올립니다. <code>WORK</code>와 <code>CARRY</code> 신체 부위가 필요합니다. 목표물은 크립의 3칸 범위 내에 있어야 합니다. 완전히 업그레이드된 8단계 컨트롤러는 15 이상의 에너지를 초과하여 업그레이드할 수 없습니다.

모든 컨트롤러가 현재 틱에서 <code>upgradeController</code>를 수행하는 누적 효과를 고려합니다. 이 제한은 <a href="/resources.html">ghodium mineral boost</a>를 사용하여 증가시킬 수 있습니다.

컨트롤러의 업그레이드는 `ticksToDowngrade` 타이머를 100으로 올립니다. 컨트롤러가 레벨 업되기 위해서는 타이머가 꽉 차야합니다.

{% api_method_params %}
target : <a href="#StructureController">StructureController</a>
업그레이드할 대상 컨트롤러 객체입니다.
{% endapi_method_params %}

### 반환값

다음 코드 중 하나:
{% api_return_codes %}
OK | 작업이 성공적으로 예약되었습니다.

오류: ERR_NOT_OWNER | 당신은 해당 크립이나 대상 컨트롤러의 소유자가 아닙니다.
ERR_BUSY | 해당 크립이 생성되고 있습니다.
ERR_NOT_ENOUGH_RESOURCES | 해당 크립에는 운반 에너지가 없습니다.
ERR_INVALID_TARGET | 대상은 유효한 컨트롤러 객체가 아닙니다. 또는 컨트롤러의 업그레이드가 차단되어 있습니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다.
ERR_NO_BODYPART | <code>WORK</code> 신체 부위가 없습니다. {% endapi_return_codes %}

{% api_method withdraw 'target, resourceType, [amount]' A %}

```javascript
if(creep. withdraw(storage, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
	creep. moveTo(storage);
}
```

자원을 구조물이나 묘비에서 인출합니다.

대상은 크립의 옆에 있어야합니다. 여러 마리의 크립이 동일한 틱 안에서 같은 객체로부터 후퇴할 수 있습니다. 적대적인 램파드가 꼭대기에 없는 경우, 여러분의 크립은 또한 적대적인 구조물/묘비로부터 자원을 후퇴할 수 있습니다.

이 방법은 크립 간에 리소스를 전송하는데 사용되지 않아야 합니다. 크립 간의 전송을 위해서는 오리지널 크립에 대한 [`transfer`](#Creep. transfer) 메소드를 사용하십시오.

{% api_method_params %}
target : <a href="#Structure">구조물</a>, <a href="#Tombstone">묘비</a>, <a href="#Ruin">폐허</a>
The target object.
===
resourceType : string
RESOURCE_* 상수들 중 하나입니다.

===
amount (선택사항) : number
전송할 자원의 양입니다. 값이 생략되면 사용 가능한 모든 금액이 사용됩니다.
{% endapi_method_params %}

### 반환값
다음과 같은 코드 중 하나:
{% api_return_codes %}
OK | 작업을 성공적으로 예약했습니다.
ERR_NOT_OWNER | 이 크립트의 소유자가 아닙니다. 또는 대상에 호스텔 램파드가 있습니다.
ERR_BUSY | 크립트가 여전히 생성되고 있습니다.
ERR_NOT_ENOUGH_RESOURCES | 대상에 주어진 자원의 양이 없습니다.
ERR_INVALID_TARGET | 대상은 지정된 리소스를 포함할 수 있는 유효한 객체가 아닙니다.
ERR_FULL | 캐리의 공간이 꽉 차 있습니다.
ERR_NOT_IN_RANGE | 대상이 너무 멀리 있습니다.

ERR_INVALID_ARGS | 자원 유형이 <code>RESOURCE_*</code> 상수 중 하나가 아니거나 금액이 올바르지 않습니다.